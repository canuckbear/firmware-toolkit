
# ----------------------------------------------------------------------------
#
# DFT firmare u-boot script for Generic Board
#
# Generation date : __GENERATION_DATE__
# DFT version     : __DFT_VERSION__
#


# ----------------------------------------------------------------------------
#
# Environnement section
#
# Definition of environment constants. These should not be redefined unless
# your really know what you are hacking.
#
# ----------------------------------------------------------------------------
setenv initrd_file    initrd.img
setenv fdtfile        'default.dtb'
setenv image          zImage
setenv dft_flag_file  dft_boot_was_dirty

# Defines the address used to env script. It is loaded at scriptaddr since
# the boot.scr has already bee loaded and imported into environnement.
setenv uenv_addr_r    ${scriptaddr}

# Defines if the rescue partition is used or not
setenv dft_use_rescue 1

# Defines if the dual_banks mode is activated
setenv dft_dual_banks 1

# Defines the current values for type device and partition only if not existing
# These are used to load uEnv, kernel, dtb and initrd
setenv flag_env_modified  0
if itest.s "x${dft_curr_type}" == "x" ; then
  setenv dft_curr_type      mmc
  setenv flag_env_modified  1
  echo "Variable dft_curr_type not yet defined adding its default value => mmc"
fi

if itest.s "x${dft_curr_dev}" == "x" ; then
  setenv dft_curr_dev       0
  setenv flag_env_modified  1
  echo "Variable dft_curr_dev  not yet defined adding its default value => 0"
fi

if itest.s "x${dft_curr_part}" == "x" ; then
  setenv dft_curr_part      1
  setenv flag_env_modified  1
  echo "Variable dft_curr_part not yet defined adding its default value => 1"
fi

if itest.s "x${dft_curr_bank}" == "x" ; then
  setenv dft_curr_bank      0
  setenv flag_env_modified  1
  echo "Variable dft_curr_bank not yet defined adding its default value => 1"
fi

# Adding a x in variable test prevents errors in case setenv went wrong
if itest.s "x${flag_env_modified}" == "x1" ; then
  echo "One or more default variables were defined, environment is now saved"
  saveenv
fi

# ----------------------------------------------------------------------------
#
# Booting from current active bank
#
# ----------------------------------------------------------------------------

# Try to load the flag file from current bank, if it fails then it means that
# it is either the first boot (flag never created), or that it has been cleared
# thus the boot was clean. In both case boot process can continue.
# if test -e ${dft_curr_type} ${dft_curr_dev}:${dft_curr_part} ${dft_flag_file} ; then
if load ${dft_curr_type} ${dft_curr_dev}:${dft_curr_part} ${uenv_addr_r} ${dft_flag_file} ; then
  echo "Normal boot"
fi


# ----------------------------------------------------------------------------
#
# Booting from failover bank
#
# ----------------------------------------------------------------------------

# Still here ?
# It means that either the dirty flag was still here, or that the boot failed
# Which alse means that the flag now exist since it has been created before trying to boot
# We have to switch bank, if multi bank is activated, and try again exactly the same code
# once banks switch.

# Test if multi bank is activated
if itest.s "${dft_multi_banks}" == "1" ; then
  # Yes, thus switch banks. Failover becomes active
  if itest.s "${dft_curr_bank}" == "0" ; then
    setenv dft_curr_bank      1
    setenv dft_curr_part      2
  else
    setenv dft_curr_bank      0
    setenv dft_curr_part      1
  fi

  # Banks have been switched, need to save env
  saveenv

  # Try again
  if load ${dft_curr_type} ${dft_curr_dev}:${dft_curr_part} ${uenv_addr_r} ${dft_flag_file} ; then
    echo "Normal boot"
    save ${dft_curr_type} ${dft_curr_dev}:${dft_curr_part} ${script_addr} ${dft_flag_file} 0
  fi
fi


# ----------------------------------------------------------------------------
#
# Booting from rescue bank
#
# ----------------------------------------------------------------------------

# Still still here ?
# It means that both banks failed and now are flaged as dirty
# Last thing to try is to boot from rescue, if rescue exist.

# Switch to rescue bank

# Test if multi bank is activated
if itest.s "${dft_use_rescue}" == "1" ; then
  # And try to boot
  if load ${dft_curr_type} ${dft_curr_dev}:${dft_curr_part} ${uenv_addr_r} ${dft_flag_file} ; then
    echo "Normal boot"
  fi
fi


# ----------------------------------------------------------------------------
#
# Booting from rescue bank failed
#
# ----------------------------------------------------------------------------

echo "Failed to boot from rescue bank"
echo "Bork ! Bork ! Bork !"

#
# First let's reset the flag meaning we have modified u-boot environment and need to save it
#
setenv flag_env_modified 0

# Checking for the last_boot_clean variable
if itest.s "x${dft_last_boot_clean}" == "x" ; then
  # Variable was not yet defined, there is nothing to do but continue with u-boot value
  echo "Variable dft_last_boot_clean is not defined. This should not happen ! Something went wrong..."
  echo "This should not happen ! Something went wrong... and uEnv.txt has probably be lost"
  echo "Trying to regenerate it, but this boot is likely to fail :("

  # Here generate env

else
  # Current dft_last_boot_state is defined, let's compare it with what we expect
  # TODO : Nope it does not work we have to exchange a token between u-boot and u-env
  # Should be something like i give you a token, you sent back this token in uEnv
  #
  # I should generate a token, set it in uboot, pass it to the kernel and check i retrieve it
  #
  if itest.s "x${dft_last_boot_clean}" != "x1" ; then
    echo "Variable dft_last_boot_clean is not what was expected. Needs to do something !"
    echo "It is time to switch to next system in sequence"
  fi
fi

# Check if uEnv defines a current type
if itest.s "x${dft_uenv_type}" == "x" ; then
  # Variable was not yet defined, there is nothing to do but continue with u-boot value
  echo "Variable dft_uenv_type not defined. Continuing with current value"
else
  # Current type is defined, let's compare it with what we expect
  if itest.s "x${dft_curr_type}" != "x${dft_uenv_type}" ; then
    echo "Variable dft_uenv_type is not what was expected. Needs to do something !"
  fi
fi

# Check if uEnv defines a current dev
if itest.s "x${dft_uenv_dev}" == "x" ; then
  # Variable was not yet defined, there is nothing to do but continue with u-boot value
  echo "Variable dft_uenv_dev not defined. Continuing with current value"
else
  # Current dev is defined, let's compare it with what we expect
  if itest.s "x${dft_curr_dev}" != "x${dft_uenv_dev}" ; then
    echo "Variable dft_uenv_dev is not what was expected. Needs to do something !"
  fi
fi

# Check if uEnv defines a current part
if itest.s "x${dft_uenv_part}" == "x" ; then
  # Variable was not yet defined, there is nothing to do but continue with u-boot value
  echo "Variable dft_uenv_part not defined. Continuing with current value"
else
  # Current part is defined, let's compare it with what we expect
  if itest.s "x${dft_curr_part}" != "x${dft_uenv_part}" ; then
    echo "Variable dft_uenv_part is not what was expected. Needs to do something !"
  fi
fi

# Adding a x in variable test prevents errors in case setenv went wrong
if itest.s "x${flag_env_modified}" == "x1" ; then
  echo "One or more uenv variables are different from expected values, environment is now saved"
  saveenv
fi



#
# Set this variables only now, because root and partition can be supereded in uEnv.txt
#
setenv mmcroot  /dev/mmcblk${dft_curr_dev}p${dft_curr_part} rootwait ro
setenv bootargs console=${console} root=${mmcroot} rootfstype=${fstype}

#
# Load the initrd into memory
#
if load ${dft_curr_type} ${dft_curr_dev}:${dft_curr_part} ${ramdisk_addr_r} ${initrd_file} ; then
  setexpr initrd_size ${filesize}
  echo "InitRD successully loaded"
else
  echo "Failed to the InitRD into memory."
  echo "Bork ! Bork ! Bork !"
fi

#
# Load the DTB into memory
#
if load ${dft_curr_type} ${dft_curr_dev}:${dft_curr_part} ${fdt_addr_r} ${fdtfile} ; then
  echo "DTB successully loaded"
else
  echo "Failed to the DTB into memory."
  echo "Bork ! Bork ! Bork !"
fi

#
# Load the kernel into memory
#
if load ${dft_curr_type} ${dft_curr_dev}:${dft_curr_part} ${kernel_addr_r} ${image} ; then
  echo "Kernel successully loaded"
else
  echo "Failed to the kernel into memory."
  echo "Bork ! Bork ! Bork !"
fi

#
# Thunderbirds are go !
#
bootz ${kernel_addr_r} ${ramdisk_addr_r}:${initrd_size} ${fdt_addr_r}
